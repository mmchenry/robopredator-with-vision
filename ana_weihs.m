function ana_weihs
% Analyzes robopredator experiments (Bill's and Kelsey's) in relation 
% To Weihs' models

%% Code execution

% Calulate and average K value for fast starts and routine swimming
do_K = 0;

% Test the results against Weihs model
model_test = 0;

% Rose plot for azimuth in global FOR 
vis_az_global = 0;

% Group responses by binocular vision
vis_az_binoc = 1;

% Scatterplot of stimulus angle vs. azimuth escape angle
scatter_stim_az = 1;

% Visualize the position of responses (visual system)
vis_visResp = 0;

% Extract visual statistics 
vis_stats = 0;

% Execute rose plots in global FOR
do_global = 0;

% Pool L/R responses in azimuth of responses
do_LR_pool = 0; 

    clr1 = .5.*[1 1 1];
    
    
comp_local = 1;


%% Parameters

% Number of bins used in rose plots
num_bin = 20;

% Marker Size 
mSize = 3;

% Period between LL detection and fast start initiation for the lateral line (s)
latency = 0.*5e-3;

% Color of 3D rendering of predator
p_clr = .7.*[1 1 1];

% Colors for the 3 speeds
sp_clr(1,:) = [0 0 1];
sp_clr(2,:) = [0 1 0];
sp_clr(3,:) = [1 0 0];

% Scale factor for spherical heads of larvae
scl_fctr = 0.0005;

% Deg per photorecptor pair (Easter, 1996) for 4 dpf
ren_den = 2.9235/180*pi;

% Behvaior to analyse
behave = 's';

% Frame rate of Kelsey's experiments
k_fps = 250;

% Speeds of fast start and routine swimming
spd_fs    = 0.45;
spd_swim  = 0.34;

% Optimal fast start angle for fast starts and swimming
alfa_fs     = [1.5123 1.2433 0.9461];
alfa_swim   = [1.5262 1.3231 1.1087];


%% Load data

% This should be specific to the computer that executes this code
%root = '/Users/arjunnair0513/Dropbox/Shared with Arjun';
root = '/Users/mmchenry/Documents/Projects/Robopredator with vision';

% Path to spline data
sp_path = '/Users/mmchenry/Documents/Matlab code/robopredator with vision';

% Load Kelsey's pooled data ('L')
load([root filesep 'kelsey data' filesep 'pooled_transdata.mat'])

% Load behavior data from Bill's experiments ('b')
load([root filesep 'bills data' filesep 'Transformed_Prey_Coords.mat'])

% Convert units of Bill's data
B.preyx   = b.preyx./100;
B.preyy   = b.preyy./100;
B.preyz   = b.preyz./100;
B.preyx2  = b.preyx2./100;
B.preyy2  = b.preyy2./100;
B.preyz2  = b.preyz2./100;
B.speed   = b.speed./100;
B.lit     = b.lit;
B.LL      = b.LL;

% Load Bill's flow cue data ('r') 
load([root filesep 'bills data' filesep 'bodycue data.mat'])

% Bills: Number of sequences
num_seq = length(b.preyx(:,1));

% Bills: Values of speeds
spds = [2 11 20];

% Load predator morphology data ('M')
load([root filesep 'bills data' filesep 'Pred3Dbodyshape.mat'])
M.x = pred3DshapeX./100;
M.y = pred3DshapeY./100;
M.z = pred3DshapeZ./100;

% Bills: Indices for each speed of sequences in the dark, with lateral line intact
index{1} = (b.speed(1:num_seq)==2) & (b.LL(1:num_seq)==1) ...
     & ~isnan(b.preyx(:,1)) & (b.lit(1:num_seq)==0);

index{2} = (b.speed(1:num_seq)==11) & (b.LL(1:num_seq)==1) ...
     & ~isnan(b.preyx(:,1)) & (b.lit(1:num_seq)==0);
 
index{3} = (b.speed(1:num_seq)==20) & (b.LL(1:num_seq)==1) ...
     & ~isnan(b.preyx(:,1)) & (b.lit(1:num_seq)==0);

clear num_seqs

% Load visual system modeling data in 'F' structure 
% (generated by model_vision.m)
load([root filesep 'kelsey data' filesep 'Visual data.mat'])    


%% Calc stats on visual stimulus, pool all data, store in 'D'
   
if vis_stats
n = 1;

% Sum of all larvae
all_larvae = length(F(1).head) + length(F(2).head) + length(F(3).head);

% Loop thru approach speeds
for i = 1:length(F)
   
    % Loop thru individuals
    for j = 1:size(F(i).head,1)
         
        % Loop thru images for each instant of time
        for k = 1:size(F(i).imR,4)
            
            % Time 
            time(k,1) = F(i).time(k,j);
            
            % Stimulated area (deg^2)
            Rarea(k,1) = sum(sum(F(i).imR(:,:,j,k))).*(ren_den/pi*180)^2;
            Larea(k,1) = sum(sum(F(i).imL(:,:,j,k))).*(ren_den/pi*180)^2;
            
            % Angular position of the area's centroid (Right)
            [iX,iY] = find(F(i).imR(:,:,j,k));
            RazCent(k,1)  = mean(mean(F(i).R_azField(iX,iY)));
            RelCent(k,1)  = mean(mean(F(i).R_elField(iX,iY)));
            RangDist(k,1) = sqrt(RazCent(k,1)^2 + RelCent(k,1)^2);
            
            % Angular position of the area's centroid (Left)
            [iX,iY] = find(F(i).imL(:,:,j,k));
            LazCent(k,1)  = mean(mean(F(i).L_azField(iX,iY)));
            LelCent(k,1)  = mean(mean(F(i).L_elField(iX,iY)));
            LangDist(k,1) = sqrt(LazCent(k,1)^2 + LelCent(k,1)^2);
            
            % Angular range (deg) of stimulus in az and el
            RazRange(k,1) = max([0 range(F(i).R_azField(F(i).imR(:,:,j,k)))/pi*180]);
            RelRange(k,1) = max([0 range(F(i).R_elField(F(i).imR(:,:,j,k)))/pi*180]);
            LazRange(k,1) = max([0 range(F(i).L_azField(F(i).imL(:,:,j,k)))/pi*180]);
            LelRange(k,1) = max([0 range(F(i).L_elField(F(i).imL(:,:,j,k)))/pi*180]);
            
            clear iX iY
        end  
        
        % Store sequence data
        D.spd(n,1)      = F(i).spd;
        D.pred_pos(n,:) = F(i).pred_pos(:,j)';
        D.t_resp(n,1)   = F(i).t_resp(j);
        D.behav(n,1)    = L(i).behav(j);
        D.az(n,1)       = L(i).az(j);
        D.el(n,1)       = L(i).el(j);
        D.azL(n,1)      = L(i).azL(j);
        D.elL(n,1)      = L(i).elL(j);
        D.head(n,:)     = L(i).head(j,:);
        D.tail(n,:)     = L(i).tail(j,:);
        D.com(n,:)      = L(i).com(j,:);
        D.com2(n,:)     = L(i).com2(j,:);
        D.wrong(n,1)    = L(i).wrong(j);
        
        % Index for time interval to be considered
        idx = (time < -.1) & (time > -.3);
        
        % Logical for whether right eye got the bigger area stim
        D.R_facing(n,1) = max(Rarea(idx)) > max(Larea(idx));
        
        % Logical for binocular stimulus
        D.binoc(n,1)    = sum(Rarea(idx))~=0 & sum(Larea(idx))~=0;
        
        % Retinal position of predator
        D.RazCent(n,1) = mean(RazCent(idx));
        D.RelCent(n,1) = mean(RelCent(idx));
        D.LazCent(n,1) = mean(LazCent(idx));
        D.LelCent(n,1) = mean(LelCent(idx));
        
        % Update status
        disp(['Done ' num2str(n) ' of ' num2str(all_larvae)])
        
        % Clear for next iteration
        clear time Rarea Larea RazCent RelCent LazCent LelCent RazRange RelRange LazRange
        clear LelRange
           
        % Advance index
        n = n + 1;
    end
end

% Save processed pooled data ('D')
save([root filesep 'pooled_processed.mat'],'D')

disp(' ');disp(' ');disp(' ');disp(' ')

else
    % Load processed pooled data ('D')
    load([root filesep 'pooled_processed.mat'])
end


%% Visulize rose plots of azimuth wrt speed (vis_az_global)

if vis_az_global
    
    clrs1 = {'k','k','k'};
    clrs2 = {'b','b','b'};
    clrs3 = {'r','r','r'};

    figure
    
    % Loop thru speeds
    for i = 1:3       
        
        % Index for current speed
        idx = ((D.behav=='f') | (D.behav=='s')) & (D.spd==spds(i));
        
        % Index for larvae that are left of the predator
        idx1 = D.com(:,2) >= 0;
        
        % Index for larvae that are right of the predator
        idx2 = ~idx1;
           
        % Loop thru individuals
        for j = 1:length(idx)
            if idx(j)
                
                % Plot position at time of response & resp direction 
                if do_LR_pool
                    subplot(2,3,i)
                else
                    subplot(3,3,i)
                end
                
                h = plot([D.head(j,1) D.tail(j,1)],...
                         [D.head(j,2) D.tail(j,2)],'-');
                     
                if idx1(j)
                    set(h,'Color',clrs2{i})
                elseif idx2(j)
                    set(h,'Color',clrs3{i})
                else
                    set(h,'Color',.8.*[1 1 1])
                end
                
                hold on
                h = plot(D.head(j,1),D.head(j,2),'o');
                
                if idx1(j)
                    set(h,'Color',clrs2{i})
                    set(h,'MarkerFaceColor',clrs2{i})
                elseif idx2(j)
                    set(h,'Color',clrs3{i})
                    set(h,'MarkerFaceColor',clrs3{i})
                else
                    set(h,'Color',.8.*[1 1 1])
                end
                
                set(h,'MarkerSize',mSize)
                
                h = plot([D.com(j,1) D.com2(j,1)],...
                         [D.com(j,2) D.com2(j,2)],'-');
                set(h,'Color',clrs1{i})
            end
        end
        
        axis equal; xlabel('X'); ylabel('Y');

        % Title
        title(['Global FOR, ' num2str(spds(i)) 'cm/s'])
        
        % Rose plots with pooled responses
        if do_LR_pool
            
            wrong_pool = [D.wrong(idx & idx1); D.wrong(idx & idx2)];
            
            % Pool responses (flip response of larvae on the right side)
            az_pool    = [D.az(idx & idx1); -D.az(idx & idx2)];
            
            subplot(2,3,i+3)
            rose_plot(az_pool,wrong_pool,num_bin)
            title('Response away from stim')
            
        % Rose plots with L and R separated
        else
            % Rose plot for when predator is on right
            subplot(3,3,i+3)
            rose_plot(D.az(idx & idx1),D.wrong(idx & idx1),num_bin)
            
            h = title('Predator on right (az)');
            set(h,'Color',clrs2{i})
            
            % Rose plot for when predator on left
            subplot(3,3,i+6)
            rose_plot(D.az(idx & idx2),D.wrong(idx & idx2),num_bin)
            
            h = title('Predator on left (az)');
            set(h,'Color',clrs3{i})
        end
    end
    
    clear az_pool
end % vis_az_global


%% Analyze Kelsey's data to determine average K values (do_K)

if do_K

spd_f = [];
spd_s = [];

% Loop thru speeds
for i = 1:length(L)
    
    % Fast start responses
    idx = L(i).behav=='f';
    
    % Displacement
    dpl = sqrt( (L(i).com2(idx,1)-L(i).com(idx,1)).^2 + ...
                   (L(i).com2(idx,2)-L(i).com(idx,2)).^2 + ...
                   (L(i).com2(idx,3)-L(i).com(idx,3)).^2 );
    
    spd_f = [spd_f; dpl(~isnan(dpl)) .* k_fps];
    
    clear dpl
    
    idx = ~(L(i).behav=='f');
    
    dpl = sqrt( (L(i).com2(idx,1)-L(i).com(idx,1)).^2 + ...
                   (L(i).com2(idx,2)-L(i).com(idx,2)).^2 + ...
                   (L(i).com2(idx,3)-L(i).com(idx,3)).^2 );
    
    spd_s = [spd_s; dpl(~isnan(dpl)) .* k_fps];

    clear dpl
end

% Clear extreme outliers
idx_f = spd_f<1;
idx_s = spd_s<1;

disp(' ')
disp(['Mean fast start speed (m/s) = ' num2str(mean(spd_f(idx_f)))])
disp(['Mean swim speed (m/s) = ' num2str(mean(spd_s(idx_s)))])

% Load pp1 & pp2
load([sp_path filesep 'Weihs spline'])



K_swim = (spds./100)./mean(spd_f(idx_f));
K_fs = (spds./100)./mean(spd_s(idx_s));

alpha_swim = eval_sp(pp1,pp2,K_swim);
alpha_fs = eval_sp(pp1,pp2,K_fs);

clear idx_f idx_s spd_f spd_s i idx

end
    

%% Analyze data to test Evasion reactions from Weihs model (model_test)

if model_test
        
    % (Rose plots, global FOR) --------------------------------------------
    
    figure

    
    % Loop thru speeds 
    for i = 1:3       
       
        % Bill's: Choose index for sequences that have stage 2 data
        idx = index{i} & ~isnan(B.preyx(:,2)) & B.preyx(:,2)>0  & B.preyx(:,3)>0;
        
        % Bill's: Get body points for all seqnences in current speed
        [Brost0,Bcom0,Btail0,Brost1,Bcom1,Btail1,Brost2,Bcom2,Btail2,Bi_vent,...
            Bi_wrong,Bprey_dir] = give_points(B,idx,latency,spds(i));
        
        % Flip nagative y values (for global FOR)
        iFlip = (Bcom1(:,2)<0) ;      
        Btail1(iFlip,2) = -Btail1(iFlip,2);
        Btail2(iFlip,2) = -Btail2(iFlip,2);
        Bcom1(iFlip,2) = -Bcom1(iFlip,2);
        Bcom2(iFlip,2) = -Bcom2(iFlip,2);
        
        % Radial coordinates
        [az_B,ttt] = cart2pol(Bcom2(:,1)-Bcom1(:,1),Bcom2(:,2)-Bcom1(:,2)); 

        
        % Kelsey's: index
        iB = L(i).behav== 'f' & ~isnan(L(i).com2(:,1));
        
        % Get COM values
        Kcom1 = L(i).com(iB,:);
        Kcom2 = L(i).com2(iB,:);
        Ktail1 = L(i).tail(iB,:);
        
        % Flip nagative y values (for global FOR)
        iFlip = (Kcom1(:,2)<0);
        Kcom1(iFlip,2)  = -Kcom1(iFlip,2);
        Ktail1(iFlip,2) = -Ktail1(iFlip,2);
        Kcom2(iFlip,2)  = -Kcom2(iFlip,2);
        
        % Radial coordinates
        [az_L,ttt] = cart2pol(Kcom2(:,1)-Kcom1(:,1),Kcom2(:,2)-Kcom1(:,2)); 

        % Polar plot
        subplot(2,3,i)
        rose_plot(az_B,num_bin,clr1)
        title(['Fast start (dark): ' num2str(spds(i)) ' cm/s'])
        
        % Draw predicted direction
        hold on
        yL = ylim;
        h = polar([alfa_fs(i) alfa_fs(i)],[0 yL(2)],'k');
        set(h,'LineWidth',3)
        
        % Polar plot
        subplot(2,3,i+3)
        rose_plot(az_L,num_bin,clr1)
        title(['Fast start (light): ' num2str(spds(i)) ' cm/s'])
        
        % Draw predicted direction
        hold on
        yL = ylim;
        h = polar([alfa_fs(i) alfa_fs(i)],[0 yL(2)],'k');
        set(h,'LineWidth',3)
        
        
        clear ttt yL h 
        clear Brost0 Bcom0 Btail0 Brost1 Bcom1 Btail1 Brost2 Bcom2 Btail2 Bi_vent
        clear Bi_wrong Bprey_dir idx Kcom1 Kcom2 iFlip iB
    end

    
    % (Position plots, global FOR) ----------------------------------------
    figure
    
    % Index for the convex hull of the predator (frontal plane)
    iP = convhull(M.x,M.y);
    
    % Index for the convex hull of the predator (sagittal plane)
    iPz = convhull(M.x,M.z);
    
    % Plot the predator
    subplot(1,2,1)
    hP = fill(M.x(iP),M.y(iP),0.*M.y(iP));
    set(hP,'FaceColor',p_clr,'LineStyle','none')
    hold on
    
    subplot(1,2,2)
    hP = fill(M.x(iP),M.y(iP),0.*M.y(iP));
    set(hP,'FaceColor',p_clr,'LineStyle','none')
    hold on

    % Step thru speeds 
    for i = 1:3
       % Kelsey's: index
        iB = L(i).behav== 'f' & ~isnan(L(i).com2(:,1));
        
        % Get COM values
        Kcom1 = L(i).com(iB,:);
        Kcom2 = L(i).com2(iB,:);
        
        % Flip negative y values
        iFlip = (Kcom1(:,2)<0);      
        Kcom1(iFlip,2) = -Kcom1(iFlip,2);
        Kcom2(iFlip,2) = -Kcom2(iFlip,2);
        
        % Displacement
        Kdispl = sqrt((Kcom1(1)-Kcom2(1)).^2 + (Kcom1(2)-Kcom2(2)).^2);
        
        % Predicted motion (Kelsey's data)
        Kcom2P(:,1)      = Kcom1(:,1) + Kdispl.*cos(alfa_fs(i));
        Kcom2P(:,2)      = Kcom1(:,2) + Kdispl.*sin(alfa_fs(i));
        %Kcom2P(iFlip,2)  = Kcom1(iFlip,2) + Kdispl.*sin(alfa_fs(i));
        %Kcom2P(~iFlip,2) = Kcom1(~iFlip,2) + Kdispl*sin(-alfa_fs(i));
        Kcom2P(:,3)      = Kcom1(:,3);

        

        % Bill's: Choose index for sequences that have stage 2 data
        idx = index{i} & ~isnan(B.preyx(:,2)) & B.preyx(:,2)>0  & B.preyx(:,3)>0;
        
        % Bill's: Get body points for all seqnences in current speed
        [Brost0,Bcom0,Btail0,Brost1,Bcom1,Btail1,Brost2,Bcom2,Btail2,Bi_vent,...
            Bi_wrong,Bprey_dir] = give_points(B,idx,latency,spds(i));
        
        % Flip negative y values
        iFlip = (Bcom1(:,2)<0) ;      
        Bcom1(iFlip,2) = -Bcom1(iFlip,2);
        Bcom2(iFlip,2) = -Bcom2(iFlip,2);
        
        % Displacement
        Bdispl = sqrt((Bcom1(1)-Bcom2(1)).^2 + (Bcom1(2)-Bcom2(2)).^2);
        
        % Predicted motion (Bill's data)
        Bcom2P(:,1)      = Bcom1(:,1) + Bdispl.*cos(alfa_fs(i));
        Bcom2P(:,2)  = Bcom1(:,2) + Bdispl.*sin(alfa_fs(i));
        %Bcom2P(~iFlip,2) = Bcom1(~iFlip,2) + Bdispl*sin(-alfa_fs(i));
        Bcom2P(:,3)      = Bcom1(:,3);
        

        % Plot Kelsey's
        subplot(1,2,1)
        for j = 1:length(Kcom1(:,1))     
            h = plot([Kcom1(j,1) Kcom2P(j,1)],[Kcom1(j,2) Kcom2P(j,2)],'k-',...
                 [Kcom1(j,1) Kcom2(j,1)],[Kcom1(j,2) Kcom2(j,2)],'r-');
            set(h(1),'Color',.5.*[1 1 1])
        end
        
        % Plot Bill's
        subplot(1,2,2)
        for j = 1:length(Bcom1(:,1))
            h = plot([Bcom1(j,1) Bcom2P(j,1)],[Bcom1(j,2) Bcom2P(j,2)],'k-',...
                 [Bcom1(j,1) Bcom2(j,1)],[Bcom1(j,2) Bcom2(j,2)],'r-');
            set(h(1),'Color',.5.*[1 1 1])
        end
        
        clear Brost0 Bcom0 Btail0 Brost1 Bcom1 Btail1 Brost2 Bcom2 Btail2 Bi_vent
        clear Bi_wrong Bprey_dir idx Kcom1 Kcom2 iFlip iB Kcom2P Bcom2P Kdispl Bdispl
        clear iFlip iB
    end
    
    subplot(1,2,1)
    title('fast start (Lights on)')
    axis square
    axis([-.01 .05 -.01 .05])
    
    subplot(1,2,2)
    title('fast start (Lights off)')
    axis square
    axis([-.01 .05 -.01 .05])
    
end


%% Compared predicted and measured direction of fast starts in local FOR

if comp_local
        
    % TODO: alter predicted angle, depending on the sign of the
    % y-coordinates
    
    
    % Containers
    LdirBP = [];
    LdirKP = [];
    LdirBM = [];
    LdirKM = [];
    LdirBod = [];
    
    % Loop thru speeds 
    for i = 1:3       
       
        % Bill's data (in DARK) -------------------------------------------
        
        % Bill's: Choose index for sequences that have stage 2 data
        idx = index{i} & ~isnan(B.preyx(:,2)) & B.preyx(:,2)>0  & B.preyx(:,3)>0;
        
        % Bill's: Get body points for all seqnences in current speed
        [Brost0,Bcom0,Btail0,Brost1,Bcom1,Btail1,Brost2,Bcom2,Btail2,Bi_vent,...
            Bi_wrong,Bprey_dir] = give_points(B,idx,latency,spds(i));
        
        % Predicted displacement in global FOR (Bill's)
        iNeg = Bcom2(:,2)<0;
        displ = sqrt((Bcom2(:,1)-Bcom1(:,1)).^2 + ...
                     (Bcom2(:,2)-Bcom1(:,2)).^2);
        BPcom2G(~iNeg,1) = Bcom1(~iNeg,1) + displ(~iNeg).*repmat(cos(alfa_fs(i)),sum(~iNeg),1);
        BPcom2G(~iNeg,2) = Bcom1(~iNeg,2) + displ(~iNeg).*repmat(sin(alfa_fs(i)),sum(~iNeg),1);
        BPcom2G(iNeg,1) = Bcom1(iNeg,1) + displ(iNeg).*repmat(cos(-alfa_fs(i)),sum(iNeg),1);
        BPcom2G(iNeg,2) = Bcom1(iNeg,2) + displ(iNeg).*repmat(sin(-alfa_fs(i)),sum(iNeg),1);
        
        BPcom2G(:,3) = Bcom1(:,3);
        
        % Predicted displacement in local FOR (Bill's)
        BPcom2L = global_to_local_indiv(Bcom1,Btail1,BPcom2G);
        BMcom2L = global_to_local_indiv(Bcom1,Btail1,Bcom2);
        
        % Radial coordinates in local FOR (Bill's)
        [az_BP,ttt] = cart2pol(BPcom2L(:,1),BPcom2L(:,2)); 
        [az_BM,ttt] = cart2pol(BMcom2L(:,1),BMcom2L(:,2)); 
        
        
        % Kelsey's data (in LIGHT) ----------------------------------------
        
        % Kelsey's: index
        iB = L(i).behav~= 'f' & ~isnan(L(i).com2(:,1));
        
        % Get COM values
        Kcom1 = L(i).com(iB,:);
        Kcom2 = L(i).com2(iB,:);
        Ktail1 = L(i).tail(iB,:);
        
        % Predicted displacement in global FOR (Kelsey's)
        iNeg = Kcom2(:,2)<0;
        displ = sqrt((Kcom2(:,1)-Kcom1(:,1)).^2 + ...
                     (Kcom2(:,2)-Kcom1(:,2)).^2);
        KPcom2G(~iNeg,1) = Kcom1(~iNeg,1) + displ(~iNeg).*repmat(cos(alfa_fs(i)),sum(~iNeg),1);
        KPcom2G(~iNeg,2) = Kcom1(~iNeg,2) + displ(~iNeg).*repmat(sin(alfa_fs(i)),sum(~iNeg),1);
        KPcom2G(iNeg,1)  = Kcom1(iNeg,1) + displ(iNeg).*repmat(cos(-alfa_fs(i)),sum(iNeg),1);
        KPcom2G(iNeg,2)  = Kcom1(iNeg,2) + displ(iNeg).*repmat(sin(-alfa_fs(i)),sum(iNeg),1);
        
        KPcom2G(:,3) = Kcom1(:,3);
        
        % Predicted displacement in local FOR (Kelsey's)
        KPcom2L = global_to_local_indiv(Kcom1,Ktail1,KPcom2G);
        KMcom2L = global_to_local_indiv(Kcom1,Ktail1,Kcom2);
        
        % Radial coordinates in local FOR (Kelsey's)
        [az_KP,ttt] = cart2pol(KPcom2L(:,1),KPcom2L(:,2)); 
        [az_KM,ttt] = cart2pol(KMcom2L(:,1),KMcom2L(:,2));
        [az_bod,ttt] = cart2pol(Kcom2(:,1)-Kcom1(:,1),Kcom2(:,2)-Kcom1(:,2));
        
        % Store results
        LdirBP = [LdirBP; az_BP];
        LdirKP = [LdirKP; az_KP];
        LdirBM = [LdirBM; az_BM];
        LdirKM = [LdirKM; az_KM];
        LdirBod = [LdirBod; az_bod];
        
        clear ttt yL h BPcom2G BPcom2L KPcom2G KPcom2L iNeg
        clear Brost0 Bcom0 Btail0 Brost1 Bcom1 Btail1 Brost2 Bcom2 Btail2 Bi_vent
        clear Bi_wrong Bprey_dir idx Kcom1 Kcom2 iFlip iB
    end
    
    % Rose plots for predicted & Measured direction (local FOR) -----------
    figure;
    
    subplot(2,2,1)
    rose_plot(LdirBM,num_bin,clr1)
    title('Measured (in dark)')
    
    subplot(2,2,2)
    rose_plot(LdirBP,num_bin,clr1)
    title('Predicted (in dark)')
    
    subplot(2,2,3)
    rose_plot(LdirKM,num_bin,clr1)
    title('Measured (in light)')
    
    subplot(2,2,4)
    rose_plot(LdirKP,num_bin,clr1)
    title('Predicted (in light)')
    
    figure
    rose_plot(LdirBod,num_bin,clr1)
    title('Body orientation (global, in light)')
end


%% Analyze data to test Avoidance reactions from Weihs model (model_test)

if model_test

    
figure

% Parameters for ODE solver    
options = odeset('RelTol',1e-7);   

% Avoidance strategies: look at the 'swimming' responses from Kelsey's
% experiments

% Loop thru speeds
for i = 1:length(L)
    
    % Store approach speed
    W(i).spd = L(i).spd;
    
    % Larvae with avoidance responses
    iLarvae = find(L(i).behav~='f');
    
    % Weihs' K value: relative speed of prey wrt predator 
    K = (L(i).spd/100) / spd_swim;
    
    % Step thru individuals
    for j = 1:length(iLarvae)
        
        % COM positions for current larva
        com1 = L(i).com(iLarvae(j),:);
        com2 = L(i).com2(iLarvae(j),:);
 
        % Displacement
        displ = sqrt((com1(1)-com2(1)).^2 + (com1(2)-com2(2)).^2);

        % Find position of case 1 prediction
        X1 = com1(1) + displ*cos(120/180*pi);
        if com1(2)>0
            Y1 = com1(2) + displ*sin(120/180*pi);
        else
            Y1 = com1(2) + displ*sin(-120/180*pi);
        end
        
        % Numerical simulation (case 2)
        [X2,Y2] = solver(com1,com2,K,options);
        
        % Find azimuth of case 2 prediction 
        [azPred,Rtmp] = cart2pol(X2(end)-com1(1),Y2(end)-com1(2));

        % Store results
        W(i).xPred2{j}      = X2; 
        W(i).yPred2{j}      = Y2;
        W(i).com1(j,:)     = com1;
        W(i).com2P1(j,:)   = [X1 Y1 com2(3)];
        W(i).com2P2(j,:)   = [X2(end) Y2(end) com2(3)];
        W(i).com2M(j,:)    = com2;
        W(i).azMeas(j,1)   = L(i).az(iLarvae(j));
        W(i).azPred2(j,1)  = azPred;
        
        clear azPred Rtmp com1 com2 X1 Y1 X2 Y2 displ y_sign
    end
end
       
% FIGURE --------------------------------------------------    
  
% Marker size
m_size = 4;

% Index for the convex hull of the predator (frontal plane)
iP = convhull(M.x,M.y);

% Index for the convex hull of the predator (sagittal plane)
iPz = convhull(M.x,M.z);

% Loop thru speeds
for i = 1:3
    
    subplot(2,3,i)
    
    % Plot the predator
    hP = fill(M.x(iP),M.y(iP),0.*M.y(iP));
    set(hP,'FaceColor',p_clr,'LineStyle','none')
    hold on
    title([num2str(W(i).spd) ' cm/s'])

    % Plot predicted and observed direction
    warning off
    hPred = arrow([W(i).com1(:,1)   W(i).com1(:,2)],...
                  [W(i).com2P2(:,1) W(i).com2P2(:,2)]); pause(.01)  
              
    hMeas = arrow([W(i).com1(:,1) W(i).com1(:,2)],...
                  [W(i).com2M(:,1) W(i).com2M(:,2)]); pause(.01)
    
    arrow(hPred,'BaseAngle',10,'Length',1,'TipAngle',65,...
                  'EdgeColor',.5.*[1 1 1],'FaceColor',.5.*[1 1 1]);           
    arrow(hMeas,'BaseAngle',10,'Length',1,'TipAngle',65,...
                  'EdgeColor','r','FaceColor','r');
    warning on
    
    axis square
    xlim([-.03 .07])
    ylim([-.05 .05])
              
    
    subplot(2,3,i+3)
    
    % Stats for scatterplot
    r2 = rSquared(W(i).azPred2,W(i).azMeas);
    [stats,slope,intercept] = reducedMajorAxis(W(i).azPred2,W(i).azMeas,1,.05,0);
    
    % Scatter plot
    h = plot(W(i).azPred2.*180/pi,W(i).azMeas.*180/pi,'ok',...
             [-180 180],[-180 180],'k-');
    set(h(2),'Color',.5.*[1 1 1])
    set(h(1),'MarkerFaceColor','k')
    set(h(1),'MarkerSize',m_size)
    hold on
    
    plot([-180 180],slope.*[-180 180]+intercept,'g')
    
%     % 120 degree lines
%     h = plot([-120 -120],[-180 0],'k--',...
%              [-180 180],[-180 180],'k-',[120 120],[180 0],'k--');
%     set(h,'Color',.5.*[1 1 1])
    
    ylabel('Measured')
    xlabel('Predicted')
    title(['r2 = ' num2str(r2) ', ' stats.hypothesis])
    axis square
    xlim([-180 180])
    ylim([-180 180])
    set(gca,'XTick',[-180:90:180])
    set(gca,'YTick',[-180:90:180])
    
    clear stats slope intercept i r2 h
    
    
end


% Pool all responses ---------------------------------------------------

figure

% Marker size
m_size = 4;

% Index for the convex hull of the predator (frontal plane)
iP = convhull(M.x,M.y);

% Index for the convex hull of the predator (sagittal plane)
iPz = convhull(M.x,M.z);

% Plot the predator
subplot(1,2,1)
hP = fill(M.x(iP),M.y(iP),0.*M.y(iP));
set(hP,'FaceColor',p_clr,'LineStyle','none')
hold on
title(['All speeds'])

azPred = [];
azMeas = [];

% Loop thru speeds
for i = 1:3
    
    subplot(1,2,1)
    % Plot predicted and observed direction
    
    for j = 1:length(W(i).com1(:,1))
        
        hPred = plot([W(i).com1(j,1) W(i).com2P2(j,1)],...
                     [W(i).com1(j,2) W(i).com2P2(j,2)],'k-');
        
        hMeas = plot([W(i).com1(j,1) W(i).com2M(j,1)],...
                     [W(i).com1(j,2) W(i).com2M(j,2)],'r-');
        
        set(hPred,'Color',.5.*[1 1 1]);
        set(hMeas,'Color','r');
        
        warning on
        
        axis square
        xlim([-.03 .07])
        ylim([-.05 .05])    
    end
  
    azPred = [azPred; W(i).azPred2];
    azMeas = [azMeas; W(i).azMeas];
end

hold off

subplot(1,2,2)

% Stats for scatterplot
r2 = rSquared(azPred,azMeas);
[stats,slope,intercept] = reducedMajorAxis(azPred,azMeas,1,.05,0);
    
% Scatter plot
h = plot(azPred.*180/pi,azMeas.*180/pi,'ok',...
         [-180 180],[-180 180],'k-');
set(h(2),'Color',.5.*[1 1 1])
set(h(1),'MarkerFaceColor','k')
set(h(1),'MarkerSize',m_size)
hold on
    
plot([-180 180],slope.*[-180 180]+intercept,'g')
    
ylabel('Measured')
xlabel('Predicted')
title(['r2 = ' num2str(r2) ', ' stats.hypothesis])
axis square
xlim([-180 180])
ylim([-180 180])
set(gca,'XTick',[-180:90:180])
set(gca,'YTick',[-180:90:180])
    
clear stats slope intercept i r2 h
clear azPred azMeas

end


%% Visulize rose plots of azimuth wrt binocular stim IN LIGHT (vis_az_binoc)

if vis_az_binoc
    
    
    % Create figure
    figure
    
    behave = 'f';
    
    % Index for binocular stimulus
    idxB = D.binoc & (D.behav==behave) & ~isnan(D.azL);
    
    % Index for left eye
    idxL = ~D.binoc & ~isnan(D.LazCent) & (D.behav==behave) & ~isnan(D.azL);
    
    % Index for right eye
    idxR = ~D.binoc & ~isnan(D.RazCent) & (D.behav==behave) & ~isnan(D.azL);
    
    % Loop thru individuals
    for j = 1:length(D.spd)
        
        if idxB(j)
            subplot(2,3,1)
            
        elseif idxL(j)
            subplot(2,3,2)
            
        elseif idxR(j)
            subplot(2,3,3)
        end
        
        h = plot([D.head(j,1) D.tail(j,1)],...
            [D.head(j,2) D.tail(j,2)],'-k');
        hold on
        h = plot(D.head(j,1),D.head(j,2),'ok');
        set(h,'Color','k')
        set(h,'MarkerFaceColor','k')
        set(h,'MarkerSize',mSize)
        h = plot([D.com(j,1) D.com2(j,1)],...
            [D.com(j,2) D.com2(j,2)],'-');
        set(h,'Color','r')
        axis equal; 
    end
    
    xlabel('X'); ylabel('Y');
    
    % Title
    if do_global
        title(['Global FOR'])
    else
        title(['Local FOR'])
    end
    
    % Rose plots (predicted, local FOR)
    subplot(1,3,1)
    rose_plot(D.azL(idxB),num_bin,clr1)
    title('Binocular stimulus (Measured)')
    
    subplot(1,3,2)
    rose_plot(D.azL(idxL),num_bin,clr1)
    title('Left eye stimulus (Measured)')
    
    subplot(1,3,3)
    rose_plot(D.azL(idxR),num_bin,clr1)
    title('Right eye stimulus (Measured)')
    
    
    % Scatterplots of response wrt stimulus -------------------------------
    if scatter_stim_az
        % Make figure window
        figure
        
        subplot(2,2,1)
        plot(D.LazCent(idxB),D.az(idxB),'or', D.LazCent(idxL),D.az(idxL),'ob')
        xlabel('angle of stimulus')
        ylabel('Azimuth of resposne (global)')
        title('Left Eye: GLOBAL')
        legend('Binoc','One eye')
        grid on
        axis equal
        
        subplot(2,2,3)
        plot(D.LazCent(idxB),D.azL(idxB),'or', D.LazCent(idxL),D.azL(idxL),'ob')
        xlabel('angle of stimulus')
        ylabel('Azimuth of response (local)')
        title('Left Eye: LOCAL')
        grid on
        axis equal
        
        subplot(2,2,2)
        plot(D.RazCent(idxB),D.az(idxB),'or',D.RazCent(idxR),D.az(idxR),'ob')
        xlabel('angle of stimulus')
        ylabel('Azimuth of resposne (global)')
        title('Right Eye: GLOBAL')
        grid on
        axis equal
        
        subplot(2,2,4)
        plot(D.RazCent(idxB),D.azL(idxB),'or',D.RazCent(idxR),D.azL(idxR),'ob')
        xlabel('angle of stimulus')
        ylabel('Azimuth of response (local)')
        title('Right Eye: LOCAL')
        grid on
        axis equal
        
        
        figure
        
        % Pool data for a combined plot
        h = plot(D.LazCent(idxL).*180/pi,D.azL(idxL).*180/pi,'go',...
                 D.RazCent(idxR).*180/pi,D.azL(idxR).*180/pi,'bo',...
                 D.LazCent(idxB).*180/pi, D.azL(idxB).*180/pi,'ro',...
                 D.RazCent(idxB).*180/pi, D.azL(idxB).*180/pi,'ro');
        axis square
        xlim([-180 180])
        ylim([-180 180])
        set(gca,'XTick',[-180:90:180])
        set(gca,'YTick',[-180:90:180])
        set(h(1),'MarkerFaceColor','g')
        set(h(2),'MarkerFaceColor','b')
        set(h(3),'MarkerFaceColor','r')
        set(h(4),'MarkerFaceColor','r')
    end
    
    clear idxB idxR idxL
end % vis_az_global




function alfa = eval_sp(pp1,pp2,K)

alfa = zeros(size(K,1),size(K,2));

idx = K>1;

if sum(idx)>=1
    alfa(idx) = fnval(pp2,K(idx));
    if sum(~idx)>=1
        alfa(~idx) = fnval(pp1,K(~idx));
    end       
else
    alfa = fnval(pp1,K);
end


function r2 = rSquared(X,Y)
% rsquared(X,Y).  This finds the r-squared value that describes the goodness of fit
% for a correlation between column vectors X and Y
if size(X,2)>1 | size(Y,2)>1
	error('You need to use two column vectors!');
end

% Example data from Chp 17 of Zar
%X = [3 4 5 6 8 9 10 11 12 14 15 16 17]';
%Y = [1.4 1.5 2.2 2.4 3.1 3.2 3.2 3.9 4.1 4.7 4.5 5.2 5.0]';

sig_x2 = sum(X.^2) - sum(X)^2/length(X);
sig_y2 = sum(Y.^2) - sum(Y)^2/length(Y);
sig_xy = sum(X.*Y) - sum(X).*sum(Y)/length(X);

ss_tot = sig_y2;
ss_regress = sig_xy^2/sig_x2;

r2 = ss_regress/ss_tot;


function rose_plot(ang,num_bin,clr)
% Creates customized rose plots (includes 95% confidence intervals)  

% Calculate and plot mean and CIs
warning off
[mu,l1,l2] = circ_mean(ang);
warning on

% Rose plot in correct direction
h = rose(ang,num_bin);
set(h,'Color',clr)
set(h,'LineWidth',1)
hold on

% Find axis limits
ymax = abs(max(ylim));

% Create series of values between CIs
r_val = linspace(l1,l2,50);

% Create polar plots: CIs
h = polar(r_val,[0 ymax.*ones(1,length(r_val)-2) 0]);
set(h,'Color',.5.*[1 1 1])
set(h,'LineStyle','-')
hold off


function  [rost0,com0,tail0,rost1,com1,tail1,rost2,com2,tail2,i_vent,...
           i_wrong,prey_dir] = give_points(b,idx,latency,spd)
% Returns the points of the prey body for all sequences denoted by 'idx'
       
% Offset in x, due to latency
lat_offset = latency * spd;

% Position (wrt predator) of body points when flow sensed
rost0 = [b.preyx(idx,1)+lat_offset b.preyy(idx,1) b.preyz(idx,1)];
com0  = [b.preyx(idx,2)+lat_offset b.preyy(idx,2) b.preyz(idx,2)];
tail0 = [b.preyx(idx,3)+lat_offset b.preyy(idx,3) b.preyz(idx,3)];

% Position (wrt predator) of body points when larva first moves
rost1 = [b.preyx(idx,1) b.preyy(idx,1) b.preyz(idx,1)];
com1  = [b.preyx(idx,2) b.preyy(idx,2) b.preyz(idx,2)];
tail1 = [b.preyx(idx,3) b.preyy(idx,3) b.preyz(idx,3)];

% Position (wrt predator) of body points at end of stage 2
rost2 = [b.preyx2(idx,1) b.preyy2(idx,1) b.preyz2(idx,1)];
com2  = [b.preyx2(idx,2) b.preyy2(idx,2) b.preyz2(idx,2)];
tail2 = [b.preyx2(idx,3) b.preyy2(idx,3) b.preyz2(idx,3)];

% Find direction of response
prey_dir(:,1) = com2(:,1) - com1(:,1);
prey_dir(:,2) = com2(:,2) - com1(:,2);
prey_dir(:,3) = com2(:,3) - com1(:,3);

% Calculate dist from midline at t1 and t2
dist1 = sqrt(com1(:,2).^2 + com1(:,3).^2);
dist2 = sqrt(com2(:,2).^2 + com2(:,3).^2);

% Index of individuals positioned ventral to predator
i_vent = com0(:,3)<=0;

% Index of responses in the 'wrong' direction
i_wrong = dist2 < dist1;


function plot_larvae(head,tail,clr,msize)
% Plots larvae

if size(head,2) == 2
    for i = 1:size(head,1)      
        h = plot(head(i,1),head(i,2),'o',[head(i,1) tail(i,1)],...
                 [head(i,2) tail(i,2)],'-');
        set(h(1),'MarkerFaceColor',clr,'MarkerEdgeColor',clr,...
                 'MarkerSize',msize)
        set(h(2),'Color',clr) 
        
        hold on
        
    end
end


function plot_resp(com1,com2,clr)
% Plots larvae

    for i = 1:size(com1,1)      
        h = plot([com1(i,1) com2(i,1)],[com1(i,2) com2(i,2)],'-');
        set(h,'Color',clr) 
        hold on       
    end

    
function ptsL = global_to_local_indiv(com,tail,pts)
% Transforms coordinates (pts, in n x 3) from global to the local coordinate
% system for each individual, assuming the y-axis of larvae runs perpendicular to gravity

% Check dimensions
if size(com,2)~=3 || size(tail,2)~=3 || size(pts,2)~=3 
    error('Input matricies must all have 3 columns')
    
elseif size(com,1)~=size(tail,1) || size(com,1)~=size(pts,1) || ...
       size(tail,1)~=size(pts,1) 
   error('Input matricies need to have equal numbers of rows')
end

% Loop thru each individual
for i = 1:size(com,1)

    % Retrieve local x axis to determine coordinate system
    xaxis(1,1) = tail(i,1) - com(i,1);
    xaxis(1,2) = tail(i,2) - com(i,2);
    xaxis(1,3) = tail(i,3) - com(i,3);
    
    % Normalize to create a unit vector
    xaxis = xaxis./norm(xaxis);
    
    %Determine local y axis
    %Short hand of cross product of inertial z axis and local x axis
    yaxis = [-xaxis(2) xaxis(1) 0];
    
    % Normalize to create a unit vector
    yaxis = yaxis./norm(yaxis);
    
    %Determine local z axis
    zaxis = cross(xaxis,yaxis);
    
    % Normalize to create a unit vector
    zaxis = zaxis./norm(zaxis);
    
    %Create rotation matrix (from inertial axes to local axes)
    R = [xaxis' yaxis' zaxis'];
    
    % Translate global coordinates wrt rostrum
    ptsT(1,1) = pts(i,1) - com(i,1);
    ptsT(1,2) = pts(i,2) - com(i,2);
    ptsT(1,3) = pts(i,3) - com(i,3);
    
    % Rotate points
    ptsL(i,:) = [inv(R) * ptsT']';
    
    % Visualize to test
    if 0
        
        blength = norm([tail(1)-com(1) tail(2)-com(2) tail(3)-com(3)]);
        
        figure
        
        subplot(2,2,[1 3])
        plot3([tail(1) com(1)],[tail(2) com(2)],[tail(3) com(3)],'b',...
            com(1),com(2),com(3),'bo');
        hold on
        plot3(pts(:,1),pts(:,2),pts(:,3),'ro')
        xlabel('x'); ylabel('y'); zlabel('z')
        hold off
        grid on;axis equal
        view(3)
        title('global')
        
        subplot(2,2,2)
        plot([0 blength],[0 0],'b',0,0,'ob',ptsT(:,1),ptsT(:,2),'ro')
        xlabel('x');ylabel('y')
        grid on; axis equal
        title('local')
        
        subplot(2,2,4)
        plot([0 blength],[0 0],'b',0,0,'ob',ptsT(:,1),ptsT(:,3),'ro')
        xlabel('x');ylabel('z')
        grid on; axis equal
    end
    
    clear xaxis yaxis zaxis R ptsR 
    
end



