function pool_kelsey
% Pools data from Kelsey's experiments
% This read csv files generated by DLT and save them into
% 'pre_response.mat', 'distance.mat', and 'noResponse.mat'
% This does all of what was formerly done by 'position_script.m'
% An earlier verison of this code was titled 'position_function.m'

%% Code execution

% Pool raw data from CSV files created by DLT Viewer
pool_raw = 1;


%% Paths

% This should be specific to each computer that executes this code
root = '/Users/arjunnair0513/Dropbox/Shared with Arjun';

% Sequences providing response data for 2 cm/s
dirs{1} = {['July_24' filesep '1'],...
           ['July_30' filesep '1']};  

% Sequences providing response data for 11 cm/s
dirs{2} = {['July_23' filesep '1'],...
           ['July_23' filesep '3'],...
           ['July_23' filesep '4']};  

% Sequences providing response data for 20 cm/s
dirs{3} = {['July_22' filesep '1'],...
           ['July_22' filesep '2'],...
           ['July_22' filesep '3']};

% Filename for responder data
resp_name = 'DLTdv5_data_xyzpts.csv';

% Filename for bubble data
bubble_name = 'bubbles_xyzpts.csv';

% Filename for larval trajectory
traj_name = 'larvae_track_xyzpts.csv';

% Filename for pooled rawdata
pooled_name = 'pooled_rawdata.mat';

% Filename fo transformed pooled data
transformed_name = 'pooled_transdata.mat';

% Filename of non-responsive larvae 
no_name = 'noResponse_xyzpts.csv';
       
% End of stage 2 postion filename
reac_name = 'response_xyzpts.csv';


%% Parameter values

% Approach speeds of the robot       
spds = [2 11 20];  

% Coding of behavioral responses for 2 cm/s
responses{1}{1} = 'scssfcssssssssssfsfsfssffsfsssfsfffsssfffssfssssfffffsffssfs';
responses{1}{2} = 'sssssssssssssssfssssssssssssssssssssss';

% Coding of behavioral responses for 11 cm/s
responses{2}{1} = 'fscfsffffsfsssssssssssccsstssstssf';
responses{2}{2} = 'tffsffffffsfssssfffssfsfsssscfss';
responses{2}{3} = 'sssfssfsfffstfffffffffffssssffscssfs';

% Coding of behavioral responses for 20 cm/s
responses{3}{1} = 'ssssffffffossfffsfssssssfsffssfs';
responses{3}{2} = 'sssssssssfsstssstcsfsssfsss';
responses{3}{3} = 'cffffffsccssscfssfsfssffsfcssfcssstcsssfftsf';

% The sequence number for the which the predator coordinates for 2 cm/s
pred_seq_num(1,1) = 1;

% The sequence number for the which the predator coordinates for 11 cm/s
pred_seq_num(2,1) = 1;

% The sequence number for the which the predator coordinates for 20 cm/s
pred_seq_num(3,1) = 2;

% Unit conversion of linear dimensions (Linear measurements from CSV files
% are in decimeters)
conv_const = 0.1;

% Angular correction (deg) of the predator's frame of reference, for each
% speed
ang_corr = [14 -19 -29]; 

% Position of the COM from anterior margin of body (body lengths)
com_pos = 0.1765;

% Frame rate of kelsey's experiments
fps = 250;


%% Pool raw data: Extract predator & bubble coordinates

if pool_raw

% Loop through each speed
for i = 1:3

    % Sequence number that contains predator coordinates
    j = pred_seq_num(i);
    
    % Read CSV data for current speed and sequence with predator
    % coordinates
    M = csvread([root filesep 'kelsey rawdata' filesep dirs{i}{j} filesep resp_name],1,0);
    
    % Index of rows lacking nans
    iNonNan = find(sum((~isnan(M)),2)~=0);
    
    % Non-nans in first non-nan row
    r = M(iNonNan(1),~isnan(M(iNonNan(1),:)));
       
    % Read CSV data for Bubble data for current sequence
    B = csvread([root filesep 'kelsey rawdata'  filesep dirs{i}{1} filesep bubble_name],1,0);
    
    % Read CSV data for Larval tracking data for current sequence
    T = csvread([root filesep 'kelsey rawdata'  filesep dirs{i}{1} filesep traj_name],1,0);
    
    % index on non-nan rows
    iT = sum((~isnan(T)),2)~=0;
    
    % Store current speed
    d(i).spd = spds(i);
    
    % Store data for predator landmark
    d(i).pred = r(1:3) .* conv_const;

    % Store data for bubble landmarks
    d(i).bubble1 = B(1,1:3) .* conv_const;
    d(i).bubble2 = B(1,4:6) .* conv_const;
              
    % Store trajectory points
    d(i).traj = T(iT,:) .* conv_const;
    
    % Clear variables
    clear M iNonNan r j iT T B
end


%% Pool raw data: Load and store responses

% Loop through each speed
for i = 1:3
    
    % Initialize fields to store data
    d(i).head     = [];
    d(i).tail     = [];
    d(i).frames1  = [];
    d(i).behav    = [];
    d(i).head2    = [];
    d(i).com2     = [];
    d(i).frames2  = [];
    
    % Loop through each sequence
    for j = 1:length(dirs{i})      
        
        % Get response data
        resp = [responses{i}{j}]';
        
        % Import pre-response data
        [indiv1,frames1,heads,tails] = csv_import([root filesep 'kelsey rawdata'  ...
                                          filesep dirs{i}{j} filesep resp_name]);
        
        % Convert into meters
        heads = heads .* conv_const;
        tails = tails .* conv_const;
                                      
        % Adjust coordinates for sequences w/pred coord
        if length(heads) == (length(responses{i}{j})+1)
            indiv1 = indiv1(2:end)-1;
            heads  = heads(2:end,:);
            tails  = tails(2:end,:);
            frames1 = frames1(2:end);
        end        
         
        % Import post-response data
        [frames2,heads2,com2] = csv_import_post([root filesep 'kelsey rawdata'  ...
                                    filesep dirs{i}{j} filesep reac_name]);
        
        % Convert into meters
        heads2 = heads2 .* conv_const;
        com2   = com2 .* conv_const;      
        
%         % Remove second coordinates, if already collected for a larva                        
%         for k = 2:(length(indiv1)-1)
%             if sum(indiv1(k)==indiv1(1:k))>1
%                 
%                 indiv1 = [indiv1(1:k-1);indiv1(k+1:end)];
%                 heads  = [heads(1:k-1,:);heads(k+1:end,:)];
%                 tails  = [tails(1:k-1,:);tails(k+1:end,:)];
%                 heads2  = [heads2(1:k-1,:);heads2(k+1:end,:)];
%                 com2  = [com2(1:k-1,:);com2(k+1:end,:)];
%                 resp  = [resp(1:k-1,:);resp(k+1:end,:)];
%             end 
%         end
        
        indiv2 = indiv1; 

        
        % Check size
        if size(heads2,1) ~= size(heads,1)
            warning([dirs{i}{j} ': mismatching number of pre-response' ...
                    'and stage 2 data'])
        end
        
        % Store results for current sequence
        d(i).head    = [d(i).head; heads];
        d(i).tail    = [d(i).tail; tails];
        d(i).frames1 = [d(i).frames1; frames1];
        d(i).head2   = [d(i).head2; heads2];
        d(i).com2    = [d(i).com2; com2];
        d(i).behav   = [d(i).behav; resp];
        d(i).frames2 = [d(i).frames2; frames2];
 
%         disp = sqrt( (heads(:,1)-heads2(:,1)).^2 + ...
%                      (heads(:,2)-heads2(:,2)).^2 + ...
%                      (heads(:,3)-heads2(:,3)).^2 ).*1000;
                 
        % Clear variables
        clear M k iNonNan heads tails k r numLarva L com2 heads2 indiv1 indiv2
        clear resp dur_resp
    end
    
    % Check data
    if size(d(i).head,1) ~= length(d(i).behav)
        error('Unequal numbers of behavior and coordinate vectors')
    end
    
    clear j 
end



%% Pool raw data: Load and store non-responses

% Loop through each speed
for i = 1:3
    
    % Initialize fields to store data
    d(i).head_non  = [];
    d(i).tail_non  = [];
   
    % Loop through each sequence
    for j = 1:length(dirs{i})      
 
        % Create variables to store coordinates
        heads = [];
        tails = [];
        
        % Read CSV data
        fPath = [root filesep 'kelsey rawdata' filesep dirs{i}{j} filesep no_name];
        M = csvread(fPath,1,0);
        
        % Index of rows lacking nans
        iNonNan = find(sum((~isnan(M)),2)~=0);
        
        % Check for predator coordinates
        if min(iNonNan)==1
            iNonNan = iNonNan(2:end);
        end
        
        % Loop through non-nan rows in CSV data
        for k = 1:length(iNonNan)
            
            % Non-nans in current row
            r = M(iNonNan(k),~isnan(M(iNonNan(k),:)));
            
            % Num of larvae in row
            numLarvae = length(r)/6;
            
            % Store data on each larva included
            for L = 1:numLarvae          
                % Store
                heads  = [heads; r(6*(L-1)+1:6*(L-1)+3)];
                tails  = [tails; r(6*(L-1)+4:6*(L-1)+6)];                
            end
            
            clear r numLarvae L
        end
        
        % Adjust coordinates for sequences w/pred coord
        if length(heads) == (length(responses{i}{j})+1)
            heads = heads(2:end,:);
            tails = tails(2:end,:);
        end
        
        % Store results for current sequence
        d(i).head_non  = [d(i).head_non; heads .* conv_const];
        d(i).tail_non  = [d(i).tail_non; tails .* conv_const];

        % Clear variables
        clear M fPath k iNonNan heads tails
    end
    
    clear j 
end



%% Pool raw data: Save pooled data


% Save pooled data
save([root filesep 'kelsey data' filesep pooled_name],'d')

end

% Clear all variables not used below
clear i responses traj_name pred_seq_num dirs bubble_name resp_name 
clear pool_raw d nonrep_name no_name nonrep conv_const


%% Define predator coordinate system, transform larval coordinates

% Load pooled rawdata ('d')
load([root filesep 'kelsey data' filesep pooled_name])

% Loop through speeds
for i = 1:3
    
    % Unit vector for direction of bubble2, relative to bubble1
    bubble_vect = d(i).bubble2 - d(i).bubble1;
    bubble_vect = bubble_vect./norm(bubble_vect);
    
    % Unit vector for the predator direction defined as opposite direction
    % of motion of passive prey
    pred_vect = threeDPredTraj(d(i).traj);
    
    % Define z-axis unit vector from bubbles and predator direction
    zaxis = cross(pred_vect,bubble_vect);
    zaxis = zaxis/norm(zaxis);
    
    xaxis = pred_vect;
    yaxis = cross(zaxis,xaxis);
    
    % Transformation matrix for the predator's FOR
    R = [xaxis',yaxis',zaxis']';
    
    % Clear variables
    clear xaxis yaxis zaxis bubble_vect pred_vect
    
    % Translate responders data wrt predator
    head_pts = bsxfun(@minus,d(i).head,d(i).pred);
    tail_pts = bsxfun(@minus,d(i).tail,d(i).pred);
    head_pts2 = bsxfun(@minus,d(i).head2,d(i).pred);
    com_pts2 = bsxfun(@minus,d(i).com2,d(i).pred);
    
    % Rotate responder data wrt predator
    head_pts = (R*(head_pts'))';
    tail_pts = (R*(tail_pts'))';
    head_pts2 = (R*(head_pts2'))';
    com_pts2 = (R*(com_pts2'))';
    
    % Rotate responder data wrt angle chosen by eye
    head_pts =  ([1 0 0;...
                  0 cosd(ang_corr(i)) -sind(ang_corr(i));...
                  0 sind(ang_corr(i)) cosd(ang_corr(i))]*head_pts')';
    tail_pts =  ([1 0 0;...
                  0 cosd(ang_corr(i)) -sind(ang_corr(i));...
                  0 sind(ang_corr(i)) cosd(ang_corr(i))]*tail_pts')';
    head_pts2 =  ([1 0 0;...
                  0 cosd(ang_corr(i)) -sind(ang_corr(i));...
                  0 sind(ang_corr(i)) cosd(ang_corr(i))]*head_pts2')';
    com_pts2 =  ([1 0 0;...
                  0 cosd(ang_corr(i)) -sind(ang_corr(i));...
                  0 sind(ang_corr(i)) cosd(ang_corr(i))]*com_pts2')';          
   
    % Correct for displacement of predator
    dur_resp       = (d(i).frames2-d(i).frames1)./fps;
    pred_disp      = (spds(i) * dur_resp)./100;
    head_pts2(:,1) = head_pts2(:,1) + pred_disp;
    com_pts2(:,1)  = com_pts2(:,1) + pred_disp;
        
    % Translate non-responder data wrt predator
    head_pts_non = bsxfun(@minus,d(i).head_non,d(i).pred);
    tail_pts_non = bsxfun(@minus,d(i).tail_non,d(i).pred);
    
    % Rotate responder data
    head_pts_non = (R*(head_pts_non'))';
    tail_pts_non = (R*(tail_pts_non'))';
    
    % Rotate responder data wrt angle chosen by eye
    head_pts_non =  ([1 0 0;...
                  0 cosd(ang_corr(i)) -sind(ang_corr(i));...
                  0 sind(ang_corr(i)) cosd(ang_corr(i))]*head_pts_non')';
    tail_pts_non =  ([1 0 0;...
                  0 cosd(ang_corr(i)) -sind(ang_corr(i));...
                  0 sind(ang_corr(i)) cosd(ang_corr(i))]*tail_pts_non')';
    
    % Loop thru individuals
    for j = 1:size(head_pts,1)    
        
        % Transform coordinate wrt prey body 
        tail_ptsL(j,:)   = global_to_local(head_pts(j,:),tail_pts(j,:),tail_pts(j,:));
        com_ptsL(j,:)    = [com_pos.*tail_ptsL(j,1) 0 0];
        head_pts2L(j,:)  = global_to_local(head_pts(j,:),tail_pts(j,:),head_pts2(j,:));
        com_pts2L(j,:)   = global_to_local(head_pts(j,:),tail_pts(j,:),com_pts2(j,:));
        
        % Determine the gobal coordinates for the COM
        com_pts(j,:) = local_to_global(head_pts(j,:),tail_pts(j,:),com_ptsL(j,:));
        
        % Initial distance from predator heading
        dist1 = sqrt(com_pts(j,2).^2 + com_pts(j,3).^2);
        
        % Final distance from heading
        dist2 = sqrt(com_pts2(j,2).^2 + com_pts2(j,3).^2);
        
        wrongs(j,1) = dist2 < dist1;
        
        clear dist1 dist2
    end    
    
    % Calculate response direction from local FOR 
    prey_dirL(:,1) = com_pts2L(:,1) - com_ptsL(:,1);
    prey_dirL(:,2) = com_pts2L(:,2) - com_ptsL(:,2);
    prey_dirL(:,3) = com_pts2L(:,3) - com_ptsL(:,3);
     
    % Check displacement of COM
    %displ = sqrt(prey_dirL(:,1).^2 + prey_dirL(:,2).^2 + prey_dirL(:,3).^2)
    
    % Angle of response wrt body
    [az_L,el_L,r_L] = cart2sph(prey_dirL(:,1),prey_dirL(:,2),prey_dirL(:,3));         
              
    % Calculate response direction from global FOR 
    prey_dirG(:,1) = com_pts2(:,1) - com_pts(:,1);
    prey_dirG(:,2) = com_pts2(:,2) - com_pts(:,2);
    prey_dirG(:,3) = com_pts2(:,3) - com_pts(:,3);
    
    % Angle of response wrt predator
    [az_G,el_G,r_G] = cart2sph(prey_dirG(:,1),prey_dirG(:,2),prey_dirG(:,3));    
            
    % Store in 'L' structure
    L(i).spd      = d(i).spd;
    L(i).pred     = d(i).pred;
    L(i).R        = R;
    L(i).behav    = d(i).behav;
    L(i).head     = head_pts;
    L(i).tail     = tail_pts;
    L(i).com      = com_pts;
    L(i).head2    = head_pts2;
    L(i).com2     = com_pts2;
    L(i).az       = az_G;
    L(i).el       = el_G;
    L(i).azL      = az_L;
    L(i).elL      = el_L;
    L(i).head_non = head_pts_non;
    L(i).tail_non = tail_pts_non; 
    L(i).wrong    = wrongs;
    
    % Clear for next iteration
    clear tail_ptsL com_ptsL head_pts2L com_pts2L com_pts head_pts_non
    clear tail_pts_non R az_G el_G azL elL r_G r_L prey_dirL prey_dirG
    clear wrongs displ dur_dirp pred_disp
end


% Save transformed pooled data
save([root filesep 'kelsey data' filesep transformed_name],'L')


%% Visualize results


figure

clrs = {'k','k','k'};
clrs2 = {'r','r','r'};

for i = 1:3
    
    for j = 1:size(L(i).head,1)
        
        subplot(2,1,1) %-------------------------------
        h = plot([L(i).head(j,1) L(i).tail(j,1)],...
                 [L(i).head(j,2) L(i).tail(j,2)],'-');
        set(h,'Color',clrs{i})
        hold on  
        h = plot(L(i).head(j,1),L(i).head(j,2),'o');
        set(h,'Color',clrs{i})
        
        h = plot([L(i).com(j,1) L(i).com2(j,1)],...
                 [L(i).com(j,2) L(i).com2(j,2)],'-');
        set(h,'Color',clrs2{i})
              
        axis equal
        
        
        subplot(2,1,2) %-------------------------------
        h = plot([L(i).head(j,1) L(i).tail(j,1)],...
                 [L(i).head(j,3) L(i).tail(j,3)],'-');
        set(h,'Color',clrs{i})
        hold on
        
        h = plot(L(i).head(j,1),L(i).head(j,3),'o');
        set(h,'Color',clrs{i})
        
        h = plot([L(i).com(j,1) L(i).com2(j,1)],...
                 [L(i).com(j,3) L(i).com2(j,3)],'-');
        set(h,'Color',clrs2{i})
        
        axis equal
        xlabel('X'); ylabel('Z')
    end
end

subplot(2,1,1)
xlabel('X'); ylabel('Y')

subplot(2,1,2)
xlabel('X'); ylabel('Z')


function [indiv,frames,pt1,pt2] = csv_import(file_path)
% Imports coordinate data from DLTViewer's CSV files
% Each individual is assumed to be described by a pair of coordinates in
% only a single frame

% Read CSV data. The rows correspond to the frame number, the columns are
% the coordinates
M = csvread(file_path,1,0);

% Initialze index
j = 1;

% Store all point pairs
for i = 1:size(M,1)
    
    % If there are values in row . . .
    if max(isnan(M(i,:)))
        
        % Indicies for values
        idx = ~isnan(M(i,:));
        
        % Column numbers for values
        col_num = find(idx);
        
        % Step thru each larva in row
        for k = 1:(sum(idx)/6)
            
            % Store individual number
            indiv(j,1)  = (col_num((k-1).*6+1)-1)/6+1;
            
            % Store frame number
            frames(j,1) = i;
            
            % Store coordinate data
            coord       = M(i,col_num(((k-1)*6+1):k*6));
            pt1(j,:)    = coord(1:3);
            pt2(j,:)    = coord(4:6);
            
            % Advance index
            j = j + 1;
            
            % Clear for next iteration
            clear coord 
        end      
    end
end


function [frames,pt1,pt2] = csv_import_post(file_path)
% Imports coordinate data from DLTViewer's CSV files
% Each individual is assumed to be described by a pair of coordinates in
% only a single frame

% Read CSV data. The rows correspond to the frame number, the columns are
% the coordinates
M = csvread(file_path,1,0);

% Initialze indicies
j = 1; i = 1;

% Store all point pairs
while i < (size(M,2)+1)
    
    % Indicies for values
    idx = ~isnan(M(:,i));
    
    % Check for only only value in column
    if sum(idx)>1
        error('More than one value in the column')
        
    % Store, if a single numerical value
    elseif sum(idx)==1
        
        % Store frame number
        frames(j,1) = find(idx);

        % Store coordinate data
        coord       = M(find(idx),i:(i+5));
        pt1(j,:)    = M(find(idx),i:(i+2));
        pt2(j,:)    = M(find(idx),(i+3):(i+5));
    
        % Advance indicies
        j = j + 1;       
        i = i + 6;
        
        % Clear for next iteration
        clear coord     
    else
        i = i + 1;
    end  
end
    


function [xT,yT,zT] = global_to_local_matrix(rost,tail,xpts,ypts,zpts)
% Transforms coordinates (pts, in n x 3) from global to local coordinate
% system, assuming the y-axis of larvae runs perpendicular to gravity

% Check dimensions
if size(rost,1)~=1 || size(rost,2)~=3 || ...
   size(tail,1)~=1 || size(tail,2)~=3 
    error('inputs have incorrect dimensions')
end

% Retrieve local x axis to determine coordinate system
xaxis(1,1) = tail(1) - rost(1);
xaxis(1,2) = tail(2) - rost(2);
xaxis(1,3) = tail(3) - rost(3);

% Normalize to create a unit vector
xaxis = xaxis./norm(xaxis);

%Determine local y axis
%Short hand of cross product of inertial z axis and local x axis
yaxis = [-xaxis(2) xaxis(1) 0];

% Normalize to create a unit vector
yaxis = yaxis./norm(yaxis);

%Determine local z axis
zaxis = cross(xaxis,yaxis);

% Normalize to create a unit vector
zaxis = zaxis./norm(zaxis);

%Create rotation matrix (from inertial axes to local axes)
R = [xaxis' yaxis' zaxis'];

% Translate global coordinates wrt rostrum
xptsT = xpts - rost(1);
yptsT = ypts - rost(2);
zptsT = zpts - rost(3);

% Rotate points
%ptsT = [inv(R) * ptsT']';

% Transformation
for i = 1:size(xptsT,2)
    
    for j = 1:size(xptsT,3)
        ptsT = [xptsT(:,i,j) yptsT(:,i,j) zptsT(:,i,j)];
        
        % Rotate points
        ptsT = [inv(R) * ptsT']';
        
        % Store
        xT(:,i,j) = ptsT(:,1);
        yT(:,i,j) = ptsT(:,2);
        zT(:,i,j) = ptsT(:,3);    
    end    
end


function ptsT = global_to_local(rost,tail,pts)
% Transforms coordinates (pts, in n x 3) from global to local coordinate
% system, assuming the y-axis of larvae runs perpendicular to gravity

% Check dimensions
if size(rost,1)~=1 || size(rost,2)~=3 ...
   size(tail,1)~=1 || size(tail,2)~=3 || size(pts,2)~=3 
    error('inputs have incorrect dimensions')
end

% Retrieve local x axis to determine coordinate system
xaxis(1,1) = tail(1) - rost(1);
xaxis(1,2) = tail(2) - rost(2);
xaxis(1,3) = tail(3) - rost(3);

% Normalize to create a unit vector
xaxis = xaxis./norm(xaxis);

%Determine local y axis
%Short hand of cross product of inertial z axis and local x axis
yaxis = [-xaxis(2) xaxis(1) 0];

% Normalize to create a unit vector
yaxis = yaxis./norm(yaxis);

%Determine local z axis
zaxis = cross(xaxis,yaxis);

% Normalize to create a unit vector
zaxis = zaxis./norm(zaxis);

%Create rotation matrix (from inertial axes to local axes)
R = [xaxis' yaxis' zaxis'];

% Translate global coordinates wrt rostrum
ptsT(:,1) = pts(:,1) - rost(1);
ptsT(:,2) = pts(:,2) - rost(2);
ptsT(:,3) = pts(:,3) - rost(3);

% Rotate points
ptsT = [inv(R) * ptsT']';

% Visualize to test
if 0
    
    blength = norm([tail(1)-rost(1) tail(2)-rost(2) tail(3)-rost(3)]);    
    
    figure
    
    subplot(2,2,[1 3])
    plot3([tail(1) rost(1)],[tail(2) rost(2)],[tail(3) rost(3)],'b',...
          rost(1),rost(2),rost(3),'bo');
    hold on
    plot3(pts(:,1),pts(:,2),pts(:,3),'ro')
    xlabel('x'); ylabel('y'); zlabel('z')
    hold off
    grid on;axis equal
    view(3)
    title('global')
    
    subplot(2,2,2)
    plot([0 blength],[0 0],'b',0,0,'ob',ptsT(:,1),ptsT(:,2),'ro')
    xlabel('x');ylabel('y')
    grid on; axis equal
    title('local')
    
    subplot(2,2,4)
    plot([0 blength],[0 0],'b',0,0,'ob',ptsT(:,1),ptsT(:,3),'ro')
    xlabel('x');ylabel('z')
    grid on; axis equal
end


function ptsT = local_to_global(rost,tail,pts)
% Transforms coordinates (pts, in n x 3) from global to local coordinate
% system, assuming the y-axis of larvae runs perpendicular to gravity

% Check dimensions of landmark coordinates
if size(rost,1)~=1 || size(rost,2)~=3 || ...
   size(tail,1)~=1 || size(tail,2)~=3
    error('inputs have incorrect dimensions')
end

% Retrieve local x axis to determine coordinate system
xaxis(1,1) = tail(1) - rost(1);
xaxis(1,2) = tail(2) - rost(2);
xaxis(1,3) = tail(3) - rost(3);

% Normalize to create a unit vector
xaxis = xaxis./norm(xaxis);

%Determine local y axis
%Short hand of cross product of inertial z axis and local x axis
yaxis = [-xaxis(2) xaxis(1) 0];

% Normalize to create a unit vector
yaxis = yaxis./norm(yaxis);

%Determine local z axis
zaxis = cross(xaxis,yaxis);

% Normalize to create a unit vector
zaxis = zaxis./norm(zaxis);

%Create rotation matrix (from inertial axes to local axes)
R = [xaxis' yaxis' zaxis'];

% If points are not meshgridded
if size(pts,2)==3
    % Rotate points
    ptsT = [R * pts']';
    
    % Translate global coordinates wrt rostrum
    ptsT(:,1) = ptsT(:,1) + rost(1);
    ptsT(:,2) = ptsT(:,2) + rost(2);
    ptsT(:,3) = ptsT(:,3) + rost(3);
    
else
    error('points need to be arranged in 3 columns')
    
end

% Visualize to test
if 0
    
    blength = norm([tail(1)-rost(1) tail(2)-rost(2) tail(3)-rost(3)]);    
    
    figure
    
    subplot(2,2,[1 3])
    plot3([tail(1) rost(1)],[tail(2) rost(2)],[tail(3) rost(3)],'b',...
          rost(1),rost(2),rost(3),'bo');
    hold on
    plot3(ptsT(:,1),ptsT(:,2),ptsT(:,3),'ro')
    xlabel('x'); ylabel('y'); zlabel('z')
    hold off
    grid on;axis equal
    view(3)
    title('global')
    
    subplot(2,2,2)
    plot([0 blength],[0 0],'b',0,0,'ob',pts(:,1),pts(:,2),'ro')
    xlabel('x');ylabel('y')
    grid on; axis equal
    title('local')
    
    subplot(2,2,4)
    plot([0 blength],[0 0],'b',0,0,'ob',pts(:,1),pts(:,3),'ro')
    xlabel('x');ylabel('z')
    grid on; axis equal
end





function pred_facing = threeDPredTraj(traj_pts)
% Unit vector for the predator direction defined as opposite direction
% of motion of passive prey

[xData, yData, zData] = prepareSurfaceData( traj_pts(:,1), traj_pts(:,2), traj_pts(:,3) );

ft = fittype( 'poly11' );
opts = fitoptions( ft );
opts.Lower = [-Inf -Inf -Inf];
opts.Robust = 'Bisquare';
opts.Upper = [Inf Inf Inf];

[fitresult, gof] = fit( [xData, yData], zData, ft, opts );

pred_facing = [0 0 0];

X = [traj_pts(1,1) traj_pts(end,1)];
Y = [traj_pts(1,2) traj_pts(end,2)];

Z = fitresult.p00 + fitresult.p10*X + fitresult.p01*Y;

pred_facing = [(X(2) -X(1)) (Y(2) -Y(1)) (Z(2) -Z(1))];

pred_facing = -pred_facing/norm(pred_facing);
